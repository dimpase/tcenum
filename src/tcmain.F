      PROGRAM TCMAIN
C
C TODD-COXETER COSET ENUMERATION USING HLT WITH LOOKAHEAD.
C FOR gfortran COMPILATION. 
C COPYRIGHT L.H.SOICHER, 1982-2024.
C
C THE MAIN PROGRAM SETS UP THE MAIN MEMORY ARRAY MEM,
C SETS UP THE VARIOUS FILES, READS IN THE DATA AND CALLS 
C THE SUBROUTINE TCGO TO DO ALL THE REAL WORK. 
C
C INTBYTES AND MAXMIB ARE GIVEN THEIR VALUES BY THE PREPROCESSOR 
C USING THE gfortran -D OPTION. 
C
C INTBYTES IS THE NUMBER OF BYTES TO USE TO STORE AN INTEGER, 
C UNLESS EXPLICITLY DECLARED OTHERWISE. THIS NUMBER SHOULD BE
C 4 OR 8.
C
C MAXMIB IS THE MAXIMUM AMOUNT OF MEMORY (IN BINARY MEGABYTES) 
C AVAILABLE FOR THE MAIN MEM ARRAY. 
C
C MAXMEM IS THE NUMBER OF INTEGERS REQUIRING INTBYTES BYTES EACH
C THAT CAN BE STORED IN MAXMIB BINARY MEGABYTES.
C
      IMPLICIT INTEGER*INTBYTES(A-Z)
      INTEGER*8 MAXMEM
      PARAMETER(MAXMEM=(MAXMIB)*2**(20_8)/(INTBYTES))
      DIMENSION MEM(MAXMEM)
C 
C MAXNAMELEN IS THE MAXIMUM PERMISSIBLE LENGTH FOR A FILENAME.
C
C THE SUBGROUP GENERATORS AND THE PRESENTATATION ARE READ FROM 
C IN_FILE. BASIC RESULTS ARE WRITTEN TO OUT_FILE. FURTHER 
C INFORMATION AND ERROR MESSAGES GO TO STANDARD OUTPUT.
C IF PERMUTATION GENERATORS ARE REQUESTED, THESE GO TO PERM_FILE.
C
      PARAMETER(MAXNAMELEN=120)
      CHARACTER(LEN=MAXNAMELEN) :: IN_FILE,OUT_FILE,PERM_FILE
      INTEGER*4 NAMELEN,STATUS
      INTEGER*8 MAXC,ILOOKA
C
C END OF DECLARATION SECTION.
C
      IF(INTBYTES.NE.4.AND.INTBYTES.NE.8)THEN
         WRITE(*,*)'ERROR - GIVEN INTEGER SIZE (IN BYTES) IS INVALID'
         STOP
      END IF
      CALL GET_COMMAND_ARGUMENT(1,IN_FILE,NAMELEN,STATUS)
      IF(STATUS.GT.0)THEN
         WRITE(*,*)'ERROR OBTAINING INPUT FILE'
         STOP
      ELSE IF(STATUS.EQ.-1)THEN
         WRITE(*,*)'ERROR - INPUT FILE NAME TOO LONG'
         STOP
      END IF   
      CALL GET_COMMAND_ARGUMENT(2,OUT_FILE,NAMELEN,STATUS)
      IF(STATUS.GT.0)THEN
         WRITE(*,*)'ERROR OBTAINING OUTPUT FILE'
         STOP
      ELSE IF(STATUS.EQ.-1)THEN
         WRITE(*,*)'ERROR - OUTPUT FILE NAME TOO LONG'
         STOP
      END IF   
      OPEN(UNIT=1,FILE=TRIM(IN_FILE))
      OPEN(UNIT=2,FILE=TRIM(OUT_FILE))
      REWIND(1)
      REWIND(2)
      READ(1,*)ILOOKA,OUTSW,NSTOP,MAXC
C ILOOKA IS THE INDEX INCREMENT AT WHICH LOOKAHEAD TAKES PLACE.
C IF ILOOKA.EQ.0 THEN LOOKAHEAD TAKES PLACE EVERY TIME THE 
C INDEX DOUBLES.
C OUTSW.EQ.1 IFF OUTPUT OF THE COSET TABLE IS REQUIRED.
C OUTSW.EQ.0 IFF OUTPUT OF THE COSET TABLE IS NOT REQUIRED.
C THE ENUMERATION FAILS IF END OF TABLE IS REACHED NSTOP TIMES.
C MAXC IS THE MAXIMUM PERMITTED NUMBER OF LIVE COSETS.
C IF THE INPUT MAXC IS 0, THIS MAXIMUM IS CALCULATED BASED ON
C THE AVAILABLE MEMORY (IN MEM).
      IF(OUTSW.EQ.1)THEN
         CALL GET_COMMAND_ARGUMENT(3,PERM_FILE,NAMELEN,STATUS)
         IF(STATUS.GT.0)THEN
            WRITE(*,*)'ERROR OBTAINING PERM. FILE'
            STOP
         ELSE IF(STATUS.EQ.-1)THEN
            WRITE(*,*)'ERROR - PERM. FILE NAME TOO LONG'
            STOP
         END IF   
         OPEN(UNIT=3,FILE=TRIM(PERM_FILE))
         REWIND(3)
      END IF
C READ IN INVERSES OF GENERATORS, SUBGROUP GENERATORS, AND RELATORS.
C STREL IS THE POINT IN  MEM  WHERE THE RELATORS BEGIN (AFTER THE
C SUBGROUP GENERATORS).
      READ(1,*)NGEN
      IF(NGEN.LE.0)THEN
         WRITE(2,*)'NO GENERATORS - TRIVIAL GROUP'
         STOP
      END IF
      IF(NGEN.GT.MAXMEM)THEN
         WRITE(*,*)'ERROR - MAXMEM TOO SMALL'
         STOP
      END IF
      READ(1,*)(MEM(J),J=1,NGEN)
      L=NGEN+1
    3 READ(1,*)LENGTH
      IF(LENGTH.EQ.0)GOTO 3
      IF(LENGTH.EQ.-2)LENGTH=0
C NOW LENGTH.EQ.0 IS USED TO INDICATE END OF RELATORS.
      IF(LENGTH.GE.0)GOTO 4
C OTHERWISE WE ARE AT THE END OF SUBGROUP GENERATORS
C AND AT THE BEGINNING OF RELATORS.
      STREL=L
      GOTO 3
    4 IF(L+LENGTH.GT.MAXMEM)THEN
         WRITE(*,*)'ERROR - MAXMEM TOO SMALL'
         STOP
      END IF
      MEM(L)=LENGTH
      IF(LENGTH.EQ.0)GOTO 2
      FRONT=L+1
      BACK=L+LENGTH
      READ(1,*)(MEM(J),J=FRONT,BACK)
      L=BACK+1
      GOTO 3
    2 IF(MAXC.EQ.0)MAXC=(MAXMEM-L)/(NGEN+2)
      IF(INTBYTES.EQ.4.AND.MAXC.GT.2*(2**30-2))THEN
         WRITE(*,*)'ERROR - MAXC TOO LARGE FOR GIVEN INTEGER SIZE'
         STOP
      ELSE IF(MAXC.LT.2)THEN
         WRITE(*,*)'ERROR - MAXC TOO SMALL'
         STOP
      ELSE IF(L+(NGEN+2)*MAXC.GT.MAXMEM)THEN
         WRITE(*,*)'ERROR - MAXMEM TOO SMALL'
         STOP
      END IF
      CALL TCGO(MEM(1),MEM(1+NGEN),MEM(L+1),MEM(L+MAXC+1),
     1          MEM(L+2*MAXC+1),
     2          NGEN,L-NGEN,STREL-NGEN,MAXC,ILOOKA,OUTSW,NSTOP)
      CLOSE(1)
      CLOSE(2)
      IF(OUTSW.EQ.1)CLOSE(3)
      STOP
      END
      SUBROUTINE TCGO(INV,W,ULINK,DLINK,T,
     1                NGEN,WLEN,STREL,MAXC,ILOOKA,OUTSW,NSTOP)
      IMPLICIT INTEGER*INTBYTES(A-Z)
      INTEGER*8 MAXC,TOTDEF,ILOOKA,NLOOKA
      LOGICAL LOOKA,CLOSED
      DIMENSION INV(NGEN),W(WLEN),ULINK(MAXC),DLINK(MAXC),T(NGEN,MAXC)
C
C MAIN SUBROUTINE TO DO COSET ENUMERATION.
C
C FIRST, INITIALIZE ACTIVE COSET LIST, FREELIST, AND COINCIDENCE QUEUE.
C IF  Y  IS IN THE COINCIDENCE QUEUE THEN  Y  IS COINCIDENT
C WITH  -ULINK(Y) (< Y).
C CURC IS THE CURRENT COSET BEING PROCESSED.
C CURW IS A POINTER TO THE CURRENT WORD CURC IS BEING PUSHED THROUGH.
C LASTCL IS THE LAST CLOSED COSET.
C LASTC IS THE LAST ACTIVE COSET.
C ASSUMES  MAXC.GE.2.
      ISTOP=0
      LASTC=1
      LASTCL=0
      CURC=1
      ULINK(1)=0
      DLINK(1)=0
      DO 5 J=1,NGEN
      T(J,1)=0
    5 CONTINUE
      CURW=1
      FREEL=2
      L=MAXC-1
      DO 6 J=2,L
      DLINK(J)=J+1
    6 CONTINUE
      DLINK(MAXC)=0
      FRONTQ=0
      BACKQ=0
      INDEX=1
      MAXDEF=1
      TOTDEF=1
      NLOOKA=ILOOKA+1
      IF(ILOOKA.EQ.0)NLOOKA=2
      LOOKA=.FALSE.
      CLOSED=.TRUE.
C MAIN LOOP.
   99 IF(LASTC.EQ.LASTCL)GOTO 88
      IF(CURC.NE.0)GOTO 7
C LOOKAHEAD FINISHED.
      WRITE(*,106)INDEX
  106 FORMAT(' LOOKAHEAD FINISHED. INDEX =',I12,/)
      IF(FREEL.EQ.0)GOTO 89
      LOOKA=.FALSE.
      CLOSED=.TRUE.
      NLOOKA=INDEX+ILOOKA
      IF(ILOOKA.EQ.0)NLOOKA=2_8*INDEX
      IF(LASTCL.EQ.0)GOTO 8
      CURC=DLINK(LASTCL)
      CURW=STREL
      GOTO 7
    8 CURC=1
      CURW=1
    7 LENGTH=W(CURW)
      FRONT=CURW+1
      BACK=CURW+LENGTH
      FRONTC=CURC
      BACKC=CURC
C FORWARD SCAN.
   12 NEXTC=T(W(FRONT),FRONTC)
      IF(NEXTC.EQ.0)GOTO 13
      FRONTC=NEXTC
      FRONT=FRONT+1
      IF(FRONT.GT.BACK)GOTO 14
      GOTO 12
C BACKWARD SCAN.
   13 NEXTC=T(INV(W(BACK)),BACKC)
      IF(NEXTC.EQ.0)GOTO 15
      BACKC=NEXTC
      BACK=BACK-1
      IF(FRONT.GT.BACK)GOTO 14
      GOTO 13
   15 IF(FRONT.EQ.BACK)GOTO 17
      IF(.NOT.LOOKA.AND.FREEL.NE.0.AND.INDEX.LT.NLOOKA)GOTO 9
      IF(LOOKA)GOTO 42
      IF(FREEL.NE.0)GOTO 43
C REACHED END OF TABLE.
      ISTOP=ISTOP+1
      IF(ISTOP.EQ.NSTOP)GOTO 89
   43 WRITE(*,110)INDEX
  110 FORMAT(' LOOKAHEAD STARTED.  INDEX =',I12)
      LOOKA=.TRUE.
   42 CLOSED=.FALSE.
      CURW=CURW+LENGTH+1
      IF(W(CURW).NE.0)GOTO 99
      CURC=DLINK(CURC)
      CURW=STREL
      CLOSED=.TRUE.
      GOTO 99
C DEFINE NEW COSET.
    9 INDEX=INDEX+1
      IF(INDEX.GT.MAXDEF)MAXDEF=INDEX
      TOTDEF=TOTDEF+1
      L=FREEL
      FREEL=DLINK(FREEL)
      CALL INSERT(L,LASTC,ULINK,DLINK,MAXC)
      LASTC=L
      DO 21 J=1,NGEN
      T(J,L)=0
   21 CONTINUE
      T(W(BACK),L)=BACKC
      T(INV(W(BACK)),BACKC)=L
      BACKC=L
      BACK=BACK-1
      GOTO 12
C DEDUCTION.
   17 T(W(FRONT),FRONTC)=BACKC
      T(INV(W(FRONT)),BACKC)=FRONTC
      FRONTC=BACKC
   14 CURW=CURW+LENGTH+1
      IF(W(CURW).NE.0)GOTO 20
      YY=CURC
      CURC=DLINK(CURC)
      CURW=STREL
C THE NEXT STATEMENT PREVENTS A COSET YY > 1 GOING BEFORE COSET 1
C ON THE ACTIVE COSET LIST.
      IF(YY.NE.1.AND.LASTCL.EQ.0)CLOSED=.FALSE.
      IF(.NOT.CLOSED.OR.ULINK(YY).EQ.LASTCL)GOTO 10
      IF(YY.EQ.LASTC)LASTC=ULINK(YY)
      CALL DELETE(YY,ULINK,DLINK,MAXC)
      CALL INSERT(YY,LASTCL,ULINK,DLINK,MAXC)
   10 IF(CLOSED)LASTCL=YY
      CLOSED=.TRUE.
   20 IF(FRONTC.EQ.BACKC)GOTO 99
C
C PROCESS COINCIDENCE.
      IF(FRONTC.LT.BACKC)THEN
      X=FRONTC
      Y=BACKC
      ELSE
      X=BACKC
      Y=FRONTC
      END IF
      INDEX=INDEX-1
      IF(Y.NE.CURC)GOTO 35
      CURC=DLINK(CURC)
      CURW=STREL
      CLOSED=.TRUE.
   35 IF(Y.EQ.LASTCL)LASTCL=ULINK(Y)
      IF(Y.EQ.LASTC)LASTC=ULINK(Y)
      CALL DELETE(Y,ULINK,DLINK,MAXC)
   23 DO 24 J=1,NGEN
      JX=T(J,X)
      IF(JX.EQ.Y)JX=X
      JY=T(J,Y)
      IF(JY.EQ.Y)JY=X
      IF(JX.EQ.0.OR.JY.EQ.0.OR.JX.EQ.JY)GOTO 24
C POSSIBLE NEW COINCIDENCE.
   30 IF(ULINK(JX).GE.0) GOTO 31
      JX=-ULINK(JX)
      GOTO 30
   31 IF(ULINK(JY).GE.0)GOTO 32
      JY=-ULINK(JY)
      GOTO 31
   32 IF(JX.EQ.JY)GOTO 24
      IF(JX.GT.JY)THEN
      TEMP=JX
      JX=JY
      JY=TEMP
      END IF
      INDEX=INDEX-1
      IF(JY.NE.CURC)GOTO 36
      CURC=DLINK(CURC)
      CURW=STREL
      CLOSED=.TRUE.
   36 IF(JY.EQ.LASTCL)LASTCL=ULINK(JY)
      IF(JY.EQ.LASTC)LASTC=ULINK(JY)
      CALL DELETE(JY,ULINK,DLINK,MAXC)
      IF(BACKQ.EQ.0)FRONTQ=JY
      ULINK(JY)=-JX
      DLINK(JY)=0
      IF(BACKQ.NE.0)DLINK(BACKQ)=JY
      BACKQ=JY
   24 CONTINUE
C UPDATE TABLE.
      DO 25 J=1,NGEN
      JY=T(J,Y)
      IF(JY.EQ.0)GOTO 25
      IF(JY.EQ.Y)T(J,Y)=X
      IF(JY.NE.Y)T(INV(J),JY)=0
   25 CONTINUE
      DO 26 J=1,NGEN
      JX=T(J,X)
      JY=T(J,Y)
      IF(JX.NE.0.OR.JY.EQ.0)GOTO 26
      IF(JY.EQ.X.AND.T(INV(J),X).NE.0)GOTO 26
      T(J,X)=JY
      T(INV(J),JY)=X
   26 CONTINUE
C RETURN Y TO THE FREELIST.
      DLINK(Y)=FREEL
      FREEL=Y
      IF(FRONTQ.EQ.0)GOTO 99
C OBTAIN NEXT COINCIDENCE TO PROCESS.
      Y=FRONTQ
      FRONTQ=DLINK(Y)
      IF(FRONTQ.EQ.0)BACKQ=0
      X=-ULINK(Y)
      GOTO 23
C
C WRITE RESULT.
   88 WRITE(*,*)'SUCCESSFUL ENUMERATION.'
      WRITE(2,102)INDEX
  102 FORMAT(/,' INDEX =',I12)
      WRITE(2,103)MAXDEF
  103 FORMAT(' MAX.  NO. OF COSETS DEFINED =',I12)
      WRITE(2,104)TOTDEF
  104 FORMAT(' TOTAL NO. OF COSETS DEFINED =',I12)
      GOTO 999
   89 WRITE(*,*)'UNSUCCESSFUL ENUMERATION.'
      WRITE(2,105)MAXC
  105 FORMAT(/,' RUN OUT OF SPACE AFTER  ',I0,'  COSETS.')
      WRITE(2,107)TOTDEF
  107 FORMAT(' TOTAL NO. OF COSETS DEFINED = ',I0)
C
C ULINK MAY BE CHANGED BY THE FOLLOWING CALL TO PGEN.
  999 CALL PGEN(T,ULINK,DLINK,NGEN,INV,LASTCL,OUTSW,MAXC)
      RETURN
      END
      SUBROUTINE DELETE(Y,ULINK,DLINK,MAXC)
C DELETES  Y  FROM THE ACTIVE COSET LIST.
C WE ASSUME  ULINK(Y).NE.0.
      IMPLICIT INTEGER*INTBYTES(A-Z)
      INTEGER*8 MAXC
      DIMENSION ULINK(MAXC),DLINK(MAXC)
      IF(DLINK(Y).NE.0)ULINK(DLINK(Y))=ULINK(Y)
      DLINK(ULINK(Y))=DLINK(Y)
      RETURN
      END
      SUBROUTINE INSERT(Y,Z,ULINK,DLINK,MAXC)
C INSERTS  Y  AFTER  Z  IN THE ACTIVE COSET LIST.
C WE ASSUME  Z.NE.0.
      IMPLICIT INTEGER*INTBYTES(A-Z)
      INTEGER*8 MAXC
      DIMENSION ULINK(MAXC),DLINK(MAXC)
      IF(DLINK(Z).NE.0)ULINK(DLINK(Z))=Y
      DLINK(Y)=DLINK(Z)
      ULINK(Y)=Z
      DLINK(Z)=Y
      RETURN
      END
      SUBROUTINE PGEN(T,MAP,DLINK,NGEN,INV,LASTCL,OUTSW,MAXC)
C IF OUTSW.EQ.1, THIS PROCEDURE OUTPUTS (PERHAPS PARTIAL) 
C PERMUTATIONS FROM THE COSET TABLE TO FORTRAN UNIT 3.
C IF OUTSW.EQ.0, THIS IS NOT DONE.
C THE UNIT 3 OUTPUT IS IN GAP 4 FORMAT FOR A SEQUENCE
C tc_permgens OF PERMUTATION GENERATORS FROM THE COSET TABLE.
C THESE "PERMUTATIONS" WILL BE PARTIAL IF THE ENUMERATION WAS
C NOT SUCCESSFUL, IN WHICH CASE, THE LAST CLOSED COSET
C NUMBER IS OUTPUT TO UNIT 2.
      IMPLICIT INTEGER*INTBYTES(A-Z)
      INTEGER*8 MAXC
      DIMENSION T(NGEN,MAXC),MAP(MAXC),DLINK(MAXC),INV(NGEN)
      IF(DLINK(LASTCL).EQ.0.AND.OUTSW.EQ.0)RETURN
      N=0
      K=1
    1 N=N+1
      MAP(K)=N
      K=DLINK(K)
      IF(K.NE.0)GOTO 1
      IF(OUTSW.EQ.0)GOTO 5
      NA=0
      DO 4 J=1,NGEN
      IF(INV(J).GE.J)NA=NA+1
    4 CONTINUE
      WRITE(3,100)'tc_permgens := ['
  100 FORMAT(A)
      ACNT=0
      DO 2 J=1,NGEN
      IF(INV(J).LT.J)GOTO 2
      ACNT=ACNT+1
      WRITE(3,100)'PermList( ['
      K=1
    3 XX=0
      IF(T(J,K).NE.0)XX=MAP(T(J,K))
      K=DLINK(K)
      IF(K.NE.0)THEN
         WRITE(3,101)XX,','
  101    FORMAT(I0,A)
         GOTO 3
      END IF
      IF(ACNT.NE.NA)THEN
         WRITE(3,101)XX,' ] ),'
      ELSE
         WRITE(3,101)XX,' ] ) ];'
      END IF
    2 CONTINUE
      IF(DLINK(LASTCL).EQ.0)RETURN
    5 XX=0
      IF(LASTCL.NE.0)XX=MAP(LASTCL)
      WRITE(2,102)XX
  102 FORMAT(' LAST CLOSED COSET = ',I0)
      RETURN
      END
